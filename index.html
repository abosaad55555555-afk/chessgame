<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess P2P Mobile</title>
    <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --board-size: min(95vw, 400px); --sq-size: calc(var(--board-size) / 8); }
        * { box-sizing: border-box; margin: 0; padding: 0; user-select: none; -webkit-tap-highlight-color: transparent; }
        body { background-color: #1a2e3f; color: white; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; min-height: 100vh; padding-top: 10px; }
        
        /* Layout Structure */
        .game-container { width: var(--board-size); display: flex; flex-direction: column; gap: 10px; }
        .ui-row { display: flex; justify-content: space-between; gap: 5px; height: 45px; }
        #status { flex: 1; background: #2c3e50; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 12px; font-weight: bold; border: 1px solid #4a5f72; padding: 0 5px; text-transform: uppercase; }
        #timer { width: 60px; background: #e67e22; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: 900; }

        /* Mess-Free Board */
        .board { width: var(--board-size); height: var(--board-size); display: grid; grid-template-columns: repeat(8, 1fr); border: 2px solid #34495e; overflow: hidden; border-radius: 4px; }
        .square { width: var(--sq-size); height: var(--sq-size); display: flex; justify-content: center; align-items: center; background-color: #f0d9b5; position: relative; font-size: calc(var(--sq-size) * 0.8); cursor: pointer; }
        .square.dark { background-color: #b58863; }
        .square.selected { background-color: #fff2b5 !important; }
        
        /* Visual Move Hints */
        .dot { width: 12px; height: 12px; background: rgba(0,0,0,0.2); border-radius: 50%; position: absolute; pointer-events: none; }
        .dot.capture { width: 85%; height: 85%; border: 4px solid rgba(0,0,0,0.1); background: transparent; }

        /* Controls & Chat */
        #copyBtn { width: 100%; padding: 15px; background: #27ae60; color: white; border: none; border-radius: 10px; font-weight: bold; font-size: 16px; box-shadow: 0 4px 0 #1e8449; margin-top: 5px; }
        .chat-box { background: #1e2b38; padding: 10px; border-radius: 10px; border: 1px solid #34495e; margin-top: 10px; }
        #messages { height: 60px; overflow-y: auto; font-size: 12px; color: #bdc3c7; margin-bottom: 5px; border-bottom: 1px solid #2c3e50; }
        #chat-input { width: 100%; padding: 12px; border-radius: 8px; border: none; background: #2c3e50; color: white; font-size: 16px; outline: none; }

        .check-alert { background: #c0392b !important; }
    </style>
</head>
<body>

<div class="game-container">
    <div class="ui-row">
        <div id="status">Connecting...</div>
        <div id="timer">60s</div>
    </div>

    <div class="board" id="board"></div>

    <button id="copyBtn">üìã COPY INVITE LINK</button>

    <div class="chat-box">
        <div id="messages"></div>
        <input type="text" id="chat-input" placeholder="Type message...">
    </div>
</div>

<script>
(function() {
    const symbols = {'r':'‚ôú','n':'‚ôû','b':'‚ôù','q':'‚ôõ','k':'‚ôö','p':'‚ôü','R':'‚ôú','N':'‚ôû','B':'‚ôù','Q':'‚ôõ','K':'‚ôö','P':'‚ôô'};
    let board = [], currentPlayer = 'w', myColor = null, selected = null, peer, conn, timeLeft = 60, timerId = null, gameOver = false;

    function initBoard() {
        board = [['r','n','b','q','k','b','n','r'],['p','p','p','p','p','p','p','p'],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['P','P','P','P','P','P','P','P'],['R','N','B','Q','K','B','N','R']];
    }

    // --- Chess Logic ---
    function canMove(fr, fc, tr, tc, tempBoard = board) {
        const p = tempBoard[fr][fc]; if (!p) return false;
        const target = tempBoard[tr][tc];
        const color = p === p.toUpperCase() ? 'w' : 'b';
        if (target && (target === target.toUpperCase() ? 'w' : 'b') === color) return false;
        const dr = Math.abs(tr - fr), dc = Math.abs(tc - fc), type = p.toLowerCase();
        if (type === 'p') {
            const dir = color === 'w' ? -1 : 1;
            if (fc === tc && !target) {
                if (tr === fr + dir) return true;
                if (tr === fr + 2*dir && (fr === 1 || fr === 6) && !tempBoard[fr+dir][fc]) return true;
            }
            if (dr === 1 && dc === 1 && target) return true; return false;
        }
        if (type === 'n') return (dr === 2 && dc === 1) || (dr === 1 && dc === 2);
        if (type === 'k') return dr <= 1 && dc <= 1;
        if (type === 'r' || type === 'q' || type === 'b') {
            if (type === 'r' && fr !== tr && fc !== tc) return false;
            if (type === 'b' && dr !== dc) return false;
            if (type === 'q' && dr !== dc && fr !== tr && fc !== tc) return false;
            const sR = tr === fr ? 0 : (tr > fr ? 1 : -1), sC = tc === fc ? 0 : (tc > fc ? 1 : -1);
            let r = fr + sR, c = fc + sC;
            while (r !== tr || c !== tc) { if (tempBoard[r][c]) return false; r += sR; c += sC; }
            return true;
        }
        return false;
    }

    function findKing(color, tempBoard = board) {
        for (let r=0; r<8; r++) for (let c=0; c<8; c++) if (tempBoard[r][c] === (color === 'w' ? 'K' : 'k')) return {r, c};
    }

    function isSquareAttacked(r, c, attackerColor, tempBoard = board) {
        for (let ir=0; ir<8; ir++) for (let ic=0; ic<8; ic++) {
            const p = tempBoard[ir][ic];
            if (p && (p === p.toUpperCase() ? 'w' : 'b') === attackerColor) if (canMove(ir, ic, r, c, tempBoard)) return true;
        }
        return false;
    }

    function wouldBeInCheck(fr, fc, tr, tc, color) {
        const temp = board.map(row => [...row]);
        temp[tr][tc] = temp[fr][fc]; temp[fr][fc] = '';
        const king = findKing(color, temp);
        return isSquareAttacked(king.r, king.c, color === 'w' ? 'b' : 'w', temp);
    }

    function executeMove(fr, fc, tr, tc) {
        board[tr][tc] = board[fr][fc]; board[fr][fc] = '';
        currentPlayer = (currentPlayer === 'w') ? 'b' : 'w';
        timeLeft = 60; render();
    }

    // --- Network ---
    function initNetwork() {
        const urlParams = new URLSearchParams(window.location.search);
        const room = urlParams.get('room');
        peer = new Peer();
        
        peer.on('open', id => {
            if (!room) {
                myColor = 'w';
                document.getElementById('status').innerText = "Host: Awaiting Peer";
                document.getElementById('copyBtn').onclick = () => {
                    const cleanPath = window.location.origin + window.location.pathname.replace(/\/$/, "");
                    const link = cleanPath + "/index.html?room=" + id;
                    const el = document.createElement('textarea');
                    el.value = link; document.body.appendChild(el); el.select();
                    document.execCommand('copy'); document.body.removeChild(el);
                    document.getElementById('copyBtn').innerText = "‚úÖ COPIED!";
                };
            } else {
                myColor = 'b';
                document.getElementById('status').innerText = "Guest: Connecting...";
                conn = peer.connect(room);
                setupConn();
            }
        });
        peer.on('connection', c => { conn = c; setupConn(); });
    }

    function setupConn() {
        conn.on('open', () => {
            document.getElementById('messages').innerHTML += "<div>System: Match Started</div>";
            document.getElementById('copyBtn').style.display = 'none';
            timerId = setInterval(() => {
                if(gameOver) return;
                timeLeft--; document.getElementById('timer').innerText = timeLeft + 's';
                if(timeLeft <= 0) { gameOver = true; render(); }
            }, 1000);
            render();
        });
        conn.on('data', data => {
            if(data.type==='move') executeMove(data.fr, data.fc, data.tr, data.tc);
            if(data.type==='chat') {
                const m = document.getElementById('messages');
                m.innerHTML += `<div>Opp: ${data.msg}</div>`;
                m.scrollTop = m.scrollHeight;
            }
        });
    }

    function render() {
        const bEl = document.getElementById('board'); bEl.innerHTML = '';
        const king = findKing(currentPlayer);
        const inCheck = isSquareAttacked(king.r, king.c, currentPlayer === 'w' ? 'b' : 'w');
        const sBox = document.getElementById('status');
        
        sBox.innerText = `${currentPlayer === 'w' ? 'White' : 'Black'}'s Turn`;
        if (inCheck) sBox.classList.add('check-alert'); else sBox.classList.remove('check-alert');
        if (gameOver) sBox.innerText = "Game Over";

        const rows = myColor === 'b' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];
        for (let r of rows) {
            for (let c = 0; c < 8; c++) {
                const s = document.createElement('div');
                s.className = `square ${(r+c)%2===0?'dark':'light'}`;
                const p = board[r][c];
                if (p) {
                    s.innerText = symbols[p];
                    s.style.color = (p === p.toUpperCase()) ? "white" : "black";
                }
                if (selected && selected.r === r && selected.c === c) s.classList.add('selected');
                if (selected && canMove(selected.r, selected.c, r, c) && !wouldBeInCheck(selected.r, selected.c, r, c, myColor)) {
                    const h = document.createElement('div'); h.className = p ? "dot capture" : "dot"; s.appendChild(h);
                }
                s.onclick = () => {
                    if (currentPlayer !== myColor || gameOver || !conn) return;
                    if (!selected) {
                        if (p && ((p === p.toUpperCase() ? 'w' : 'b') === myColor)) { selected = {r, c}; render(); }
                    } else {
                        if (canMove(selected.r, selected.c, r, c) && !wouldBeInCheck(selected.r, selected.c, r, c, myColor)) {
                            conn.send({type: 'move', fr: selected.r, fc: selected.c, tr: r, tc: c});
                            executeMove(selected.r, selected.c, r, c);
                        }
                        selected = null; render();
                    }
                };
                bEl.appendChild(s);
            }
        }
    }

    document.getElementById('chat-input').onkeypress = e => {
        if (e.key === 'Enter' && conn && e.target.value.trim()) {
            conn.send({type: 'chat', msg: e.target.value});
            document.getElementById('messages').innerHTML += `<div>Me: ${e.target.value}</div>`;
            e.target.value = '';
        }
    };

    initBoard(); initNetwork(); render();
})();
</script>
</body>
</html>